<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Coraz√≥n 3D San Valent√≠n</title>

<style>
    body {
        margin: 0;
        overflow: hidden;
        background: black;
    }

    .titulo {
        position: absolute;
        top: 30px;
        width: 100%;
        text-align: center;
        font-size: 40px;
        color: #ffc0cb;
        text-shadow: 0 0 20px #ff69b4, 0 0 40px #ff1493;
        z-index: 10;
    }
</style>
</head>
<body>

<div class="titulo">Feliz D√≠a Evalia!!</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/controls/OrbitControls.js"></script>

<script>

//////////////////////////////////
// üß† DETECTAR M√ìVIL
//////////////////////////////////

const isMobile = /Mobi|Android/i.test(navigator.userAgent);

//////////////////////////////////
// üé¨ ESCENA
//////////////////////////////////

const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    0.1,
    3000
);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

camera.position.z = 120;

//////////////////////////////////
// üåç CONTROLES
//////////////////////////////////

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.enablePan = false;
controls.rotateSpeed = isMobile ? 0.8 : 1.2;

//////////////////////////////////
// üåå ESTRELLAS
//////////////////////////////////

const starCount = isMobile ? 3000 : 6000;
const starsGeometry = new THREE.BufferGeometry();
const starPositions = new Float32Array(starCount * 3);

for (let i = 0; i < starCount * 3; i++) {
    starPositions[i] = (Math.random() - 0.5) * 2000;
}

starsGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));

const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 1 });
const stars = new THREE.Points(starsGeometry, starsMaterial);
scene.add(stars);

//////////////////////////////////
// ‚ù§Ô∏è FUNCI√ìN CORAZ√ìN
//////////////////////////////////

function heartEquation(t) {
    const x = 16 * Math.pow(Math.sin(t), 3);
    const y = 13 * Math.cos(t)
        - 5 * Math.cos(2 * t)
        - 2 * Math.cos(3 * t)
        - Math.cos(4 * t);
    return { x, y };
}

//////////////////////////////////
// ‚ù§Ô∏è CORAZ√ìN S√ìLIDO
//////////////////////////////////

const particleCount = isMobile ? 30000 : 60000;
const heartGeometry = new THREE.BufferGeometry();
const positions = new Float32Array(particleCount * 3);

for (let i = 0; i < particleCount; i++) {

    const t = Math.random() * Math.PI * 2;
    const heart = heartEquation(t);
    const scale = Math.random() * 3;

    positions[i * 3] = heart.x * scale;
    positions[i * 3 + 1] = heart.y * scale;
    positions[i * 3 + 2] = (Math.random() - 0.5) * 30 * scale;
}

heartGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

const heartMaterial = new THREE.PointsMaterial({
    color: 0xff1493,
    size: 0.8
});

const heart = new THREE.Points(heartGeometry, heartMaterial);
scene.add(heart);

// Guardamos posiciones originales
const originalPositions = positions.slice();

//////////////////////////////////
// üí• CLICK / TOUCH ‚Üí TEXTO
//////////////////////////////////

function handleInteraction() {

    const x = (Math.random() - 0.5) * 200;
    const y = (Math.random() - 0.5) * 150;
    const z = (Math.random() - 0.5) * 100;

    createExplosionText("Evalia", x, y, z);
}

window.addEventListener("click", handleInteraction);
window.addEventListener("touchstart", handleInteraction);

function createExplosionText(text, x, y, z) {

    const canvas = document.createElement("canvas");
    const context = canvas.getContext("2d");

    canvas.width = isMobile ? 400 : 600;
    canvas.height = isMobile ? 200 : 300;

    const gradient = context.createLinearGradient(0, 0, canvas.width, 0);
    gradient.addColorStop(0, "#ff69b4");
    gradient.addColorStop(0.5, "#ffc0cb");
    gradient.addColorStop(1, "#ff1493");

    context.fillStyle = gradient;
    context.font = isMobile ? "bold 60px Arial" : "bold 100px Arial";
    context.textAlign = "center";
    context.textBaseline = "middle";

    context.shadowColor = "#ff69b4";
    context.shadowBlur = 30;

    context.fillText(text, canvas.width / 2, canvas.height / 2);

    context.lineWidth = 4;
    context.strokeStyle = "#ffffff";
    context.strokeText(text, canvas.width / 2, canvas.height / 2);

    const texture = new THREE.CanvasTexture(canvas);
    const material = new THREE.SpriteMaterial({ 
        map: texture, 
        transparent: true 
    });

    const sprite = new THREE.Sprite(material);

    sprite.position.set(x, y, z);
    sprite.scale.set(isMobile ? 35 : 50, isMobile ? 18 : 25, 1);

    scene.add(sprite);

    let scale = 1;

    function animateText() {
        scale += 0.05;
        sprite.scale.set(
            (isMobile ? 35 : 50) * scale,
            (isMobile ? 18 : 25) * scale,
            1
        );

        sprite.material.opacity -= 0.02;

        if (sprite.material.opacity <= 0) {
            scene.remove(sprite);
        } else {
            requestAnimationFrame(animateText);
        }
    }

    animateText();
}

//////////////////////////////////
// üîÑ LOOP CON VIDA
//////////////////////////////////

function animate() {
    requestAnimationFrame(animate);

    // üíì Latido general
    const pulse = 1 + Math.sin(Date.now() * 0.003) * 0.05;
    heart.scale.set(pulse, pulse, pulse);

    // ‚ú® Part√≠culas aleatorias que aparecen/desaparecen
    const positionAttr = heartGeometry.attributes.position;

    for (let i = 0; i < particleCount; i++) {

        if (Math.random() < 0.002) {

            const i3 = i * 3;
            const factor = Math.random() < 0.5 ? 0.2 : 1;

            positionAttr.array[i3]     = originalPositions[i3]     * factor;
            positionAttr.array[i3 + 1] = originalPositions[i3 + 1] * factor;
            positionAttr.array[i3 + 2] = originalPositions[i3 + 2] * factor;
        }
    }

    positionAttr.needsUpdate = true;

    controls.update();
    renderer.render(scene, camera);
}

animate();

//////////////////////////////////
// üì± RESPONSIVE
//////////////////////////////////

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

</script>

</body>
</html>
